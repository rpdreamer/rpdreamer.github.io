{"meta":{"title":"Resory","subtitle":null,"description":"","author":"Sya Resory","url":"https://resorie.github.io/blog","root":"/blog/"},"pages":[{"title":"关于我","date":"2020-10-04T01:04:16.301Z","updated":"2020-10-04T01:04:16.301Z","comments":true,"path":"about/index.html","permalink":"https://resorie.github.io/blog/about/index.html","excerpt":"","text":""},{"title":"分类","date":"2020-10-03T05:54:57.266Z","updated":"2020-10-03T05:54:57.266Z","comments":false,"path":"categories/index.html","permalink":"https://resorie.github.io/blog/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-10-03T05:54:14.292Z","updated":"2020-10-03T05:54:14.292Z","comments":false,"path":"tags/index.html","permalink":"https://resorie.github.io/blog/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"浅谈KMP算法——单模式串匹配","slug":"about-kmp","date":"2020-12-26T10:49:36.000Z","updated":"2021-01-10T12:33:37.296Z","comments":true,"path":"posts/about-kmp/","link":"","permalink":"https://resorie.github.io/blog/posts/about-kmp/","excerpt":"$\\text{KMP}$ 算法是一种单模式串匹配算法，由 $\\mathsf{D.E.Knuth}$、$\\mathsf{J.H.Morris}$ 和 $\\mathsf{V.R.Pratt}$ 在 1977 年共同提出，可以在 $\\Theta(n+m)$ 的时间复杂度内实现单个模式串的匹配。","text":"$\\text{KMP}$ 算法是一种单模式串匹配算法，由 $\\mathsf{D.E.Knuth}$、$\\mathsf{J.H.Morris}$ 和 $\\mathsf{V.R.Pratt}$ 在 1977 年共同提出，可以在 $\\Theta(n+m)$ 的时间复杂度内实现单个模式串的匹配。 模式串匹配所谓模式串匹配，就是给定一个主串 S 以及一个模式串 P ，查询 P 在 S 中出现的次数以及位置。例如： \\begin{aligned} S: \\qquad & \\texttt{ABABCBAABA} \\\\ P: \\qquad & \\texttt{ABA} \\end{aligned} \\\\ \\quad \\\\ \\color{green}{\\texttt{ABA}}\\texttt{BCBCA}\\color{green}{\\texttt{ABA}}\\\\ \\Uparrow \\qquad \\ \\ \\ \\ \\Uparrow\\\\ \\color{green}{\\texttt{ABA} \\qquad \\ \\ \\ \\texttt{ABA}} \\\\ \\small\\textsf{pos=0} \\qquad \\small\\textsf{pos=8}主串为 ABABCBAABA，模式串为ABA，匹配结果是出现两次，分别从下标0和8开始，其中主串下标从0开始。 我们先从最朴素的暴力算法（BF算法）说起。 暴力（Brute-Force算法）最朴素的算法就是，对于每个位置循环匹配，遇到不相同的字符就返回。 123456789int bf(string s,string p) &#123; int cnt = 0,n = s.size(),m = p.size(); for(int i = 0;i &lt; n - m + 1;i ++) &#123; for(int j = 0;j &lt; m;j ++) if(s[i + j] != p[j]) break; if(j == m) ++ cnt,printf(&quot;pos=%d\\n&quot;,i); &#125; return cnt;&#125; 还是刚才那个例子，暴力算法的运行流程如下： \\begin{aligned} S: \\qquad & \\texttt{ABABCBAABA} \\\\ P: \\qquad & \\texttt{ABA} \\end{aligned} \\\\ \\quad \\\\ \\texttt{ABABCBCAABA}\\\\ \\color{green}{\\texttt{ABA}}\\ \\small\\textsf{pos=0} \\quad \\ \\ \\ \\\\ \\texttt{AB}\\color{red}{\\texttt{A}} \\qquad \\quad \\ \\\\ \\color{red}{\\texttt{A}} \\qquad \\quad \\ \\\\ \\texttt{AB}\\color{red}{\\texttt{A}} \\quad \\\\ \\color{red}{\\texttt{A}} \\quad \\\\ \\color{red}{\\texttt{A}} \\\\ \\ \\ \\ \\ \\color{red}{\\texttt{A}} \\\\ \\qquad \\ \\ \\texttt{A}\\color{red}{\\texttt{B}} \\\\ \\qquad \\qquad \\qquad \\ \\ \\ \\color{green}{\\texttt{ABA}}\\ \\small\\textsf{pos=8} \\\\这种方法的时间复杂度最坏为 $O(nm)$，最好为 $O(n)$，并且很容易被卡，不能接受。 暴力算法的优化思路注意到，暴力匹配每次失配时都会将开始的下标增加1，而配对多次时这样的弊端就十分明显了。因此，我们要考虑降低比较的趟数。我们发现，如果匹配 $S[l\\dots (l+\\operatorname{len}(P)-1)]$ 是在下标 $r$ 处失败的，那么主串的子串 $S[l\\dots r - 1]$ 一定等于 $P[0\\dots r-l]$！比如： \\begin{aligned} S: \\qquad & \\texttt{ALGORITHM} \\\\ P: \\qquad & \\texttt{ALPHA} \\end{aligned} \\\\ \\begin{aligned} & \\color{green}{\\texttt{AL}}\\texttt{GORITHM}\\\\ & \\color{green}{\\texttt{AL}}\\color{red}{\\texttt{PHA}} \\end{aligned} \\\\ \\small\\text{（绿色这一段是相等的）}于是这能告诉我们，主串的某个子串等于格式串的某个前缀。我们就要用这个信息跳过一些不可能成功的比较。 前缀函数对于一个字符串 $s$，它的前缀函数 $\\pi$ 定义为一个长度为 $\\operatorname{len}(s)$ 的数组（在 OI 中一般写作nxt数组），其中 $\\pi(i)$ 的定义为 $s$ 的子串 $s[0\\dots i]$ 中最长的相等的真前缀和真后缀的长度。用数学语言描述如下： \\pi(i)=\\max_{k=0\\dots i} \\left\\{k:s[0\\dots (k-1)]=s[(i-k+1)\\dots i]\\right\\}举个例子：若 $s$ 等于abababc，则： $\\pi(0)=0$，因为子串a没有相等的真前缀和真后缀； $\\pi(1)=0$，因为子串ab没有相等的真前缀和真后缀； $\\pi(2)=1$，因为子串aba最长的相等的真前缀和真后缀a长度为 $1$； $\\pi(3)=2$，因为子串abab最长的相等的真前缀和真后缀ab长度为 $2$； $\\pi(4)=3$，因为子串ababa最长的相等的真前缀和真后缀aba长度为 $3$； $\\pi(5)=4$，因为子串ababab最长的相等的真前缀和真后缀abab长度为 $4$； $\\pi(6)=0$，因为子串abababc没有相等的真前缀和真后缀。 综上，abababc的前缀函数值为 $[0,0,1,2,3,0]$。 计算前缀函数直接按照函数定义计算： 循环变量 $i\\Rightarrow 1 \\operatorname{to} n$ 计算 $\\pi(i)$ 的值（此时 $\\pi(0)$ 被默认赋值为 $0$）； 令内层循环变量 $j \\Rightarrow i \\operatorname{to}0$，表示 $\\pi(i)$ 的值。如果当前长度下真前缀和真后缀相等（即 $s[0\\dots(j-1)]=s[(i-j+1)\\dots i]$），那么停止循环， $\\pi(i)=j$。 查看代码 123456789void getNxt(string s,int nxt[]) &#123; int n = s.size(); for(int i = 1;i &lt; n;i ++) &#123; for(int j = i;j &gt;= 0;j --) if(s.substr(0,j) == s.substr(i - j + 1,j)) break; nxt[i] = j; &#125; return ;&#125; 由于substr函数的时间复杂度为 $O(n)$，显然这种算法的时间复杂度为 $O(n^3)$，不能接受，考虑优化。 考虑从 $\\pi(i-1)$ 与 $\\pi(i)$ 的关系入手。分 $s[\\pi(i-1)]=s[i]$ 和 $s[\\pi(i-1)]\\not=s[i]$ 两种情况讨论。 $s[\\pi(i-1)]=s[i]$，即： \\underbrace{\\overbrace{s_0\\ s_1\\ s_2}^{\\pi(i-1)=3}\\ s_3}_{\\pi(i)=4}\\ \\dots\\ \\underbrace{\\overbrace{ s_{i-3}\\ s_{i-2}\\ s_{i-1}}^{\\pi(i-1)=3}\\ s_{i}}_{\\pi(i)=4}\\quad \\left(s_3=s_i\\right)显然可以得出：$\\pi(i)=\\pi(i-1)+1$。 $s[\\pi(i-1)]\\not=s[i]$，即： \\overbrace{\\underbrace{s_0\\ s_1}_{j=2}\\ s_2}^{\\pi(i-1)=3}\\ s_3\\ \\dots\\ \\overbrace{s_{i-3}\\ \\underbrace{s_{i-2}\\ s_{i-1}}_{j=2}}^{\\pi(i-1)=3}\\ s_i\\quad \\left(s_3\\not=s_i\\right)则我们继续找出 $s[0\\dots(i-1)]$ 中第二长的相等的真前缀和真后缀，记这个长度为 $j$。再次比较 $s[i]$ 和 $s[j]$。如果相等，则 $\\pi(i)=j+1$。否则，继续找出 $s[0\\dots(i-1)]$ 中第二长的相等的真前缀和真后缀，长度为 $j_2$，继续比较 $s[i]$ 和 $s[j_2]$。如此循环往复，直至 $j_k=0$ 或 $s[i]=s[j_k]$ 为止，此时 $\\pi(i)=j_k+[s[i]=s[j_k]]$ （中括号表示当括号内表达式为真时值为 $1$，否则值为 $0$）。 观察上图我们可以发现：$s[0\\dots(j-1)]=s[(i-j)\\dots(i-1)]$。又根据前缀函数的性质，我们可以得出：$s[(i-j)\\dots(j-1)]=s[(\\pi(i-1)-j)\\dots(\\pi(i-1)-1)]$。等量代换后可以得到：$s[0\\dots(j-1)]=s[(\\pi(i-1)-j)\\dots(\\pi(i-1)-1)]$。我们发现，$j$ 的值恰好符合 $\\pi(\\pi(i-1)-1)$ 的定义！同理也可以得出 $j_2=\\pi(j-1)$。由此我们可以得出，$j_k=\\pi(j_{k-1}-1)$。所以我们可以循环迭代这个过程，求出前缀函数的值。 查看代码 123456789void getNxt(string s,int nxt[]) &#123; int n = s.size(); for(int i = 1,j = 0;i &lt; n;i ++) &#123; while(j &gt; 0 &amp;&amp; s[i] != s[j]) j = nxt[j - 1]; if(s[i] == s[j]) j ++; nxt[i] = j; &#125; return ;&#125; 不难得出，求解前缀函数的时间复杂度为 $\\Theta(m)$。 KMP算法$\\text{KMP}$ 算法的精髓在于，通过已经匹配完成的字符段，利用前缀函数的性质，跳过不可能的匹配，从而节省时间。 直接看个例子： \\begin{aligned} S: \\qquad & \\texttt{BABCBABCABCAABCABCABCACABC} \\\\ P: \\qquad & \\texttt{ABCABCACAB} \\end{aligned} \\\\ \\quad我们首先对模式串 P 求解前缀函数，得到 $\\{0,0,0,1,2,3,4,0,1,2\\}$。接着，按照 $i\\Rightarrow 0 \\operatorname{to} n, j\\Rightarrow 0 \\operatorname{to} m$ 依次匹配 $S[i]$ 和 $P[i+j]$。当 $i=0$ 时： 此时，$S[0]\\not=P[0]$，在 $j=0$ 处失配。于是我们将 $i$ 指针右移一格，继续匹配： 在 $j=3$ 处失配。此时我们可以得到 $S[i\\dots(i+j-1)]=P[0\\dots(j-1)]$。于是我们计算 $P[0\\dots(j-1)]$ 的最长相等真前缀和真后缀的长度 $\\pi(j-1)$。我们发现，$j$ 指针可以直接移动到 $\\pi(j-1)$ 的位置并直接比较 $S[i]$ 与 $P[j]$。于是，我们令 $i=i+j$，然后循环计算 $j=\\pi(j-1)$ 直到 $j \\le 0 \\operatorname{or} S[i]=P[j]$ 为止。 计算后可以得到：$i=4,j=0$。但由于此时 $S[i]$ 仍然不等于 $P[j]$，我们直接将 $i$ 指针右移一格继续匹配。 在 $j=7$ 处失配。继续重复计算 $j=\\pi(j-1)$。 计算得到：$i=12,j=4$。继续匹配，在 $j=7$ 处失配。继续重复计算 $j=\\pi(j-1)$。 计算得到 $i=15,j=4$。此时，匹配成功，记录成功位置 $pos=15$。仿照之前的过程继续计算。 由于 $i$ 指针到达 $S$ 串末尾，停止匹配。 可以发现，$\\text{KMP}$ 算法的匹配过程其实和求解前缀函数的过程十分相似。这是因为，求解前缀函数的过程其实就类似于模式串和自己匹配的过程。整个匹配过程的代码也很简单： 查看代码 123456789101112int nxt[maxn];int kmp(string s,string p) &#123; int cnt = 0,n = s.size(),m = p.size(); getNxt(p,nxt); for(int i = 1,j = 0;i &lt; n;i ++) &#123; while(j &gt; 0 &amp;&amp; s[i] != p[j]) j = nxt[j - 1]; if(s[i] == p[j]) j ++; if(j == m) printf(&quot;%d\\n&quot;,i - m + 1),j = nxt[j - 1],cnt ++; &#125; return cnt;&#125; 利用摊还分析，我们可以得到，$\\text{KMP}$ 算法的时间复杂度为 $\\Theta(n+m)$。 例题 Loj #103. 子串查找给定一个字符串 $A$ 和一个字符串 $B$，求 $B$ 在 $A$ 中的出现次数。$A$ 和 $B$ 中的字符均为英语大写字母或小写字母。$A$ 中不同位置出现的 $B$ 可重叠。 $\\text{KMP}$ 模板题。直接套板子即可。 查看代码 123456789101112131415161718192021222324252627282930313233343536#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;iostream&gt;const int maxn = 1e6 + 5;using std::string;string a,b;int n,m,nxt[maxn];void getNxt(string s,int nxt[]) &#123; int n = s.size(); for(int i = 1,j = 0;i &lt; n;i ++) &#123; while(j &amp;&amp; s[i] != s[j]) j = nxt[j - 1]; if(s[i] == s[j]) j ++; nxt[i] = j; &#125; return ;&#125;int kmp(string s,string p) &#123; int cnt = 0,n = s.size(),m = p.size(); getNxt(p,nxt); for(int i = 0,j = 0;i &lt; n;i ++) &#123; while(j &amp;&amp; s[i] != p[j]) j = nxt[j - 1]; if(s[i] == p[j]) j ++; if(j == m) j = nxt[j - 1],cnt ++; &#125; return cnt;&#125;int main() &#123; std::cin &gt;&gt; a &gt;&gt; b; printf(&quot;%d\\n&quot;,kmp(a,b)); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"字符串","slug":"编程/字符串","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]},{"title":"【题解】[NOI2018]屠龙勇士","slug":"soln-P4774","date":"2020-10-08T03:44:07.000Z","updated":"2021-01-07T14:13:44.391Z","comments":true,"path":"posts/soln-P4774/","link":"","permalink":"https://resorie.github.io/blog/posts/soln-P4774/","excerpt":"","text":"题目链接 算是一个比较简单的NOI题，数论萌（神）新（仙）练（秒）手（切）题。 前置知识：扩展中国剩余定理（excrt）求解一个线性同余方程组： \\left\\{ \\begin{array}{lr} x \\equiv q_1 \\pmod {p_1}, &\\\\ x \\equiv q_2 \\pmod {p_2}, &\\\\ x \\equiv q_3 \\pmod {p_3}, &\\\\ \\dots &\\\\ x \\equiv q_n \\pmod {p_n}. \\end{array} \\right.（$q_1,q_2,q_3\\dots,q_n$ 不两两互质） 由于并没有简单的直接求解的办法，所以考虑分开求解。 假设求解到第 $i$ 个方程，前面 $i-1$ 个方程结果为 $ans$ ，模数的 $\\operatorname{lcm}$ 是 $M$ ，则可以列出一个方程组： \\left\\{ \\begin{array}{lr} x \\equiv ans \\pmod {M}, &\\\\ x \\equiv q_i \\pmod {p_i}. \\end{array} \\right.为了简便，我们用 $a_{1,2}$ 代表余数， $b_{1,2}$ 代表模数，则有： x = k_1 \\cdot b_1+a_1=k_2 \\cdot b_2+a_2\\ (k_{1,2} \\in \\mathbb Z)移项得： k_1 \\cdot b_1 - k_2 \\cdot b_2 = a_2-a_1令 $G=\\gcd(b_1,b_2)$ ，若 $G \\not| (a_2-a_1)$ ，则无解。否则用 exgcd 求解方程 $b_1x’+b_2y’=G$，可得 $k_1=\\dfrac{x’ \\cdot (a_2-a_1)}{G}$ ，带回即可求出 $x$ 的值。 本题题解Part 1 初始化首先我们发现，杀死龙的顺序是确定的，每次杀龙的剑也是确定的，这就说明我们可以用 $multiset$ 模拟选剑的过程，每次 upper_bound 一下就行了。 123456789101112131415161718192021ll n,m,a[maxn],p[maxn],award[maxn],atk[maxn];multiset &lt; ll &gt; sword;void input() &#123; n = func::read(),m = func::read(); // read是定义在命名空间func中的快读函数 for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); // 第i条龙的生命值 for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); // 第i条龙的恢复能力 for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); // 杀死第i条龙的奖励 for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); // 把所有剑的攻击力存储进multiset中&#125;void init() &#123; multiset &lt; ll &gt;::iterator it; for(int i = 1;i &lt;= n;i ++) &#123; it = sword.upper_bound(a[i]); // upper_bound出第i把剑的攻击力 if(it != sword.begin()) it --; atk[i] = *it; sword.erase(it); sword.insert(award[i]); // 插入杀死第i条龙的奖励 &#125;&#125; 我们又发现，杀死龙的步骤为：以 $atk_i$ 的攻击力攻击 $x$ 下，回复若干次 $p_i$ 生命值，生命值变为 $0$ 。这是不是感觉很耳熟？没错，这就是一个同余方程。我们可以根据这个过程列出这样一个方程： atk_i \\cdot x \\equiv a_i \\pmod{p_i}然而这并不符合 excrt 的规范，因此我们可以移项，两边同时乘上 $atk_i$ 关于 $p_i$ 的 $atk_i^{-1}$ ： x \\equiv a_i \\cdot atk_i^{-1} \\pmod{p_i}于是我们得到了得到方程组的代码： 1234567891011bool init_equotion() &#123; for(int i = 1;i &lt;= n;i ++ ) &#123; ll g = func::gcd(p[i],a[i]); // 此段代码中gcd定义在命名空间func中 g = func::gcd(g,atk[i]); a[i] /= g,p[i] /= g,atk[i] /= g; if(func::gcd(atk[i],p[i]) != 1) return false; // 不互质则不存在逆元 返回false表示无解 q1[i] = func::fmul(a[i],func::inv(atk[i],p[i]),p[i]); // 处理方程组 p1[i] = p[i]; &#125; return true;&#125; Part 2 一些特例我们发现，有的数据并不保证 $a_i\\le p_i$ ，这时可能就会出现一种情况：龙的生命值依旧大于0，但是已经和 $p_i$ 同余了。 怎么办呢？ 多半是废了！ 但是，经过仔细观察数据范围，可以发现，对于所有不满足 $a_i\\le p_i$ 的数据，都保证 $p_i=1$ ！这意味着我们可以直接特判掉这些情况，答案即为 $\\max\\left\\{\\left\\lfloor\\dfrac{a_i}{atk_i}\\right\\rfloor\\right\\}$。代码如下： 123456789101112namespace sp &#123; bool check() &#123; // 检查是否符合特殊情况 for(int i = 1;i &lt;= n;i ++) if(p[i] != 1) return false; return true; &#125; void solve_sp() &#123; ll ans = -1; for(int i = 1;i &lt;= n;i ++) ans = func::max(ans,(a[i] + atk[i] - 1) / atk[i]); printf(&quot;%lld\\n&quot;,ans); &#125;&#125; Part 3 解决普遍情况当解决完特殊情况并且处理完方程组后，我们就可以套上 excrt 的板子大干一场了： 123456789101112131415161718192021222324252627282930void excrt() &#123; ll M = p1[1]; ll ans = q1[1]; for(int i = 2;i &lt;= n;i ++) &#123; ll k1,x,y; // 按照excrt的方法求解 ll g = func::exgcd(M,p1[i],x,y); ll c = (q1[i] - ans % p1[i] + p1[i]) % p1[i]; if(c % g != 0) &#123; puts(&quot;-1&quot;); return ; &#125; // 无解 k1 = func::fmul(x,c / g,p1[i] / g); // 龟速乘 防爆long long ans = M * k1 + ans; M = M / g * p1[i]; ans = (ans % M + M) % M; &#125; ans = (ans % M + M) % M; printf(&quot;%lld\\n&quot;,ans);&#125;void solve() &#123; sword.clear(); n = func::read(),m = func::read(); for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); func::init(); if(sp::check()) sp::solve_sp(); else if(init_equotion()) excrt(); else puts(&quot;-1&quot;);&#125; 完整代码： 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;set&gt;typedef long long ll;using std::multiset;const int maxn = 100005;ll t,n,m,a[maxn],p[maxn],award[maxn],atk[maxn];multiset &lt; ll &gt; sword;namespace func &#123; inline ll max(ll a,ll b) &#123; return a &gt; b ? a : b; &#125; inline ll read() &#123;#define gc c = getchar() ll d = 0; int f = 0,gc; while(c &lt; 48 || c &gt; 57) f |= (c == &#x27;-&#x27;),gc; while(c &gt; 47 &amp;&amp; c &lt; 58) d = (d &lt;&lt; 1) + (d &lt;&lt; 3) + (c ^ 48),gc;#undef gc return f ? -d : d; &#125; ll gcd(ll a,ll b) &#123; if(!b) return a; return gcd(b,a % b); &#125; ll exgcd(ll a,ll b,ll&amp; x1,ll&amp; y1) &#123; if(!b) &#123; x1 = 1,y1 = 0; return a; &#125; ll x2,y2,ans = exgcd(b,a % b,x2,y2); x1 = y2; y1 = x2 - a / b * y2; return ans; &#125; ll inv(ll a,ll p) &#123; ll x,y; exgcd(a,p,x,y); return (x % p + p) % p; &#125; ll fmul(ll a,ll b,ll mod) &#123; ll rep = 0; while(b) &#123; if(b &amp; 1) rep = (rep + a) % mod; a = (a &lt;&lt; 1) % mod,b &gt;&gt;= 1; &#125; return rep; &#125; void init() &#123; multiset &lt; ll &gt;::iterator it; for(int i = 1;i &lt;= n;i ++) &#123; it = sword.upper_bound(a[i]); if(it != sword.begin()) it --; atk[i] = *it; sword.erase(it); sword.insert(award[i]); &#125; &#125;&#125;namespace sp &#123; bool check() &#123; for(int i = 1;i &lt;= n;i ++) if(p[i] != 1) return false; return true; &#125; void solve_sp() &#123; ll ans = -1; for(int i = 1;i &lt;= n;i ++) ans = func::max(ans,(a[i] + atk[i] - 1) / atk[i]); printf(&quot;%lld\\n&quot;,ans); &#125;&#125;namespace soln &#123; ll p1[maxn],q1[maxn]; bool init_equotion() &#123; for(int i = 1;i &lt;= n;i ++ ) &#123; ll g = func::gcd(p[i],a[i]); g = func::gcd(g,atk[i]); a[i] /= g,p[i] /= g,atk[i] /= g; if(func::gcd(atk[i],p[i]) != 1) return false; q1[i] = func::fmul(a[i],func::inv(atk[i],p[i]),p[i]); p1[i] = p[i]; &#125; return true; &#125; void excrt() &#123; ll M = p1[1]; ll ans = q1[1]; for(int i = 2;i &lt;= n;i ++) &#123; ll k1,x,y; ll g = func::exgcd(M,p1[i],x,y); ll c = (q1[i] - ans % p1[i] + p1[i]) % p1[i]; if(c % g != 0) &#123; puts(&quot;-1&quot;); return ; &#125; k1 = func::fmul(x,c / g,p1[i] / g); ans = M * k1 + ans; M = M / g * p1[i]; ans = (ans % M + M) % M; &#125; ans = (ans % M + M) % M; printf(&quot;%lld\\n&quot;,ans); &#125; void solve() &#123; sword.clear(); n = func::read(),m = func::read(); for(int i = 1;i &lt;= n;i ++) a[i] = func::read(); for(int i = 1;i &lt;= n;i ++) p[i] = func::read(); for(int i = 1;i &lt;= n;i ++) award[i] = func::read(); for(int i = 1;i &lt;= m;i ++) sword.insert(func::read()); func::init(); if(sp::check()) sp::solve_sp(); else if(init_equotion()) excrt(); else puts(&quot;-1&quot;); &#125;&#125;int main() &#123; freopen(&quot;dragon.in&quot;,&quot;r&quot;,stdin); freopen(&quot;dragon.out&quot;,&quot;w&quot;,stdout); t = func::read(); for(;t;t --) soln::solve(); fclose(stdin); fclose(stdout); return 0;&#125;","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"题解","slug":"编程/题解","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]},{"title":"浅谈珂朵莉树（ODT）","slug":"about-ODT","date":"2020-10-03T05:44:09.000Z","updated":"2021-01-10T12:35:59.170Z","comments":true,"path":"posts/about-ODT/","link":"","permalink":"https://resorie.github.io/blog/posts/about-ODT/","excerpt":"珂朵莉树（ODT）是一种玄学数据结构，得名于Codeforces 896 C，可以在较快的时间复杂度内实现区间赋值和区间修改等操作。","text":"珂朵莉树（ODT）是一种玄学数据结构，得名于Codeforces 896 C，可以在较快的时间复杂度内实现区间赋值和区间修改等操作。 0x00 Prologue在太阳西斜的这个世界里， 置身天上之森。 等这场战争结束之后， 不归之人与望眼欲穿的众人， 人人本着正义之名， 长存不灭的过去、逐渐消逝的未来。 我回来了，纵使日薄西山，即便看不到未来， 此时此刻的光辉，盼君勿忘。 这几天闲着慌，就去学了学珂朵莉树，作为一个很有用的骗分数据结构，个人认为还是有必要学一学的。 反正又不难 0x01 What is it?珂朵莉树起源于Codeforces 896 C，由于出题人的CF id为Old Driver，因此又被称为Old Driver Tree（ODT）。 原题需要我们实现一种数据结构，可以快速维护以下操作：（保证数据随机） 区间加； 区间赋值； 求区间第 $k$ 小； 求区间 $k$ 次方和。 很明显，普通的线段树等数据结构都很难实现这种要求，但是这种似乎很复杂的数据结构，在出题人这位毒瘤眼中竟然可以用…… 暴力实现？ 珂朵莉树的思想在于把一段连续的值相同的区间用一个结构体来存储，由于数据随机且有大量区间赋值操作，这样的结构体数量会大大减少，从而保证了珂朵莉树接近线性的时间复杂度。 乍一看，珂朵莉树似乎并不像是一个树形数据结构，但因为它一般基于 $std::set$ 来实现，而 $std::set$ 本质是红黑树，所以也跟“树”勉强搭得上边。 0x02 如何实现？珂朵莉树的精髓在于区间推平操作会产生大量的元素值相同的区间，因此我们用三个变量 $l,r,v$ 来表示一个下标为 $[l,r]$ 中元素值为 $v$ 的区间。接着我们把这些三元组存储到 $std::set$ 中。写成代码就是这样的： 12345678struct node &#123; int l,r; mutable int v; // 这里mutable关键字保证了可以直接在set中修改v的值 node() &#123;&#125; node(int L,int R,int V): l(L),r(R),v(V) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125; // 按照区间所在的位置排序&#125;; typedef set &lt; node &gt; :: iterator iter; // 简化迭代器set &lt; node &gt; s; // 存储到std::set中 比如当输入数据为1 2 2 2 3 3 4 4时， $set$ 内存储的数据就是这样的： 操作1：split然而，我们操作的区间并不总是正好覆盖我们存储的区间。因此我们需要一个函数来实现分裂开每个区间的操作，也就是split函数。split函数接受一个参数 $pos$ ，然后把包含 $pos$ 的区间 $[l,r]$ “分裂”成 $[l,pos)$ 和 $[pos,r]$ ： 123456789iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); // lower_bound寻找包含pos的区间 if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; // 如果已经存在就直接返回 it --; // 往前数一个才是我们想要的 ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); // 删除原来的 s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first; // 分裂成两个并返回后面一个的迭代器&#125; 对于刚才那个图，如果我们执行split(4)，那么他就会变成这样： 这里的运行流程：lower_bound找到区间 $$ ，往前回滚找到 $$ ，并将其修改成 $$ 和 $$ 。 在进行区间操作时，我们常常要左右端点各split一次，此时我们要先split右端点，否则左端点的迭代器可能会失效而导致错误。 操作2：assign很明显，如果操作中全是split的话，区间数会越来越多，复杂度必然爆炸。这时我们就需要区间赋值操作减少区间数量：assign。 assign函数接受三个参数，表示区间和要赋的值。赋值时，把左右端点split一下，然后把中间的部分变成一个新的区间就行了： 12345void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); // 左右端点各split一遍 s.erase(itl,itr); // 两端点之间的节点全部删去 s.insert(node(l,r,v)); // 插入新的区间&#125; 还是刚刚那个图，如果我们执行assign(3,5,5)，就变成了这个亚子： 其他操作：暴力出奇迹区间加：一个一个加一遍就完事了 1234void add(int l,int r,int x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125; 区间第 $k$ 大：塞到 $vector$ 里排序就完事了 1234567891011int kth(int l,int r,int k) &#123; vector &lt; pair &lt; int,int &gt; &gt; vec; // pair存储值以及区间长度 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); // 默认优先按照第一关键字排序 for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125; 区间 $k$ 次方和：每个取出来做快速幂求和就完事了 1234567int sum(int l,int r,int x,int y) &#123; // x次方和除以y的余数 int res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; // fpow就是快速幂 return res;&#125; 真的是暴力出奇迹……然而因为split和assign的存在， $set$ 中的区间数量也不会太多，所以速度可以保证。不过如果数据不随机，珂朵莉树还是很容易被hack掉的。比如CF896C中提供了一个随机数生成器就是为了防止hack。 最后附上CF896C的全部代码： 查看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;vector&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,m,seed,vmax,op,l,r,x,y;ll a[100005];ll rnd(ll mod) &#123; ll ret = seed; seed = (seed * 7 + 13) % 1000000007; return ret % mod + 1;&#125;ll fpow(ll a, ll b, ll mod) &#123; ll res = 1,ans = a % mod; while(b) &#123; if(b &amp; 1) res = res * ans % mod; ans = ans * ans % mod; b &gt;&gt;= 1; &#125; return res;&#125;iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;void add(ll l,ll r,ll x) &#123; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v += x;&#125;ll kth(ll l,ll r,ll k) &#123; vector &lt; pair &lt; ll,ll &gt; &gt; vec; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) vec.push_back(make_pair(itl -&gt; v,itl -&gt; r - itl -&gt; l + 1)); sort(vec.begin(),vec.end()); for(int i = 0;i &lt; vec.size();i ++) &#123; k -= vec[i].second; if(k &lt;= 0) return vec[i].first; &#125;&#125;ll sum(ll l,ll r,ll x,ll y) &#123; ll res = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) res = (res + (itl -&gt; r - itl -&gt; l + 1) % y * fpow(itl -&gt; v,x,y) % y) % y; return res;&#125;int main() &#123; scanf(&quot;%lld%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;seed,&amp;vmax); for(int i = 1;i &lt;= n;i ++) &#123; a[i] = rnd(vmax); s.insert(node(i,i,a[i])); &#125; for(int i = 1;i &lt;= m;i ++) &#123; op = rnd(4),l = rnd(n),r = rnd(n); if(l &gt; r) swap(l,r); if (op == 3) x = rnd(r - l + 1); else x = rnd(vmax); if (op == 4) y = rnd(vmax); switch(op) &#123; case 1: add(l,r,x); break; case 2: assign(l,r,x); break; case 3: printf(&quot;%lld\\n&quot;,kth(l,r,x)); break; case 4: printf(&quot;%lld\\n&quot;,sum(l,r,x,y)); break; &#125; &#125; return 0;&#125; 0x03 更广泛的运用1. CF915E Physical Education Lessons 有两种操作，每次操作把区间内的值全部赋成0或1，求每次操作后整个序列内元素的和。 区间赋值+区间求和，简直是珂朵莉树的模板！不过在这题中，我们可以把sum函数简化掉，只需要在assign中求和即可。 查看代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;typedef long long ll;struct node &#123; ll l,r; mutable ll v; node() &#123;&#125; node(ll _l,ll _r,ll _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;ll n,q,sum; // sum存储区间和iter split(ll pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; ll l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(ll l,ll r,ll v) &#123; int cnt = 0,len = 0; // cnt代表区间内的和，len代表区间长度 iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,v)); if (v == 1) sum += (len - cnt); else sum -= cnt; // 更新sum的值&#125;int main() &#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;q); sum = n,s.insert(node(1,n,1)); for(int l,r,k;q;q --) &#123; scanf(&quot;%lld%lld%lld&quot;,&amp;l,&amp;r,&amp;k); assign(l,r,k == 1 ? 0 : 1); printf(&quot;%lld\\n&quot;,sum); &#125; return 0;&#125; 2. 洛谷P1047 校门外的树我知道这题可以用模拟差分线段树分块做 但如果把区间长度 $L$ 的范围加大到$10^9$，这些方法就不行了。这时我们就要祭出今天的主角：珂朵莉树。 由于 $m$ 的范围并没有那么大，因此区间的数量并不会那么多（在 $O(m)$ 级别）。由于题目只要求实现区间清零的操作，我们可以直接仿照上个例子来完成。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;int L,m,sum;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r) &#123; int cnt = 0,len = 0; iter itr = split(r + 1),itl = split(l); for(iter it = itl;it != itr;it ++) &#123; len += (it -&gt; r - it -&gt; l + 1); cnt += it -&gt; v * (it -&gt; r - it -&gt; l + 1); &#125; s.erase(itl,itr); s.insert(node(l,r,0)); sum -= cnt;&#125;int main() &#123; scanf(&quot;%d%d&quot;,&amp;L,&amp;m); sum = L + 1,s.insert(node(0,L,1)); for(int l,r;m;m --) &#123; scanf(&quot;%d%d&quot;,&amp;l,&amp;r); assign(l,r); &#125; printf(&quot;%d\\n&quot;,sum); return 0;&#125; 如果真的遇到这道题，且不保证数据随机时，珂朵莉树有可能被hack掉，此时这题的正解应该是离散化+差分。 3. 洛谷P2572 [SCOI2010]序列操作一道不错的练习珂朵莉树骗分的题目。很明显，第0,1,3个操作都是珂朵莉树的板子，而其他两个操作只要稍作修改就行了： 查看代码 区间取反：1234void reverse(int l,int r) &#123; // 挨个取出来取反 iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) itl -&gt; v ^= 1; // 值异或1是个简单的取反方法&#125;求区间最大连续1的长度：12345678int query(int l,int r) &#123; int ans = 0,sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) // 挨个取出来计数 if(itl -&gt; v) sum += itl -&gt; r - itl -&gt; l + 1; else ans = ans &gt; sum ? ans : sum,sum = 0; return ans &gt; sum ? ans : sum;&#125; 对于本题，有两个注意点：下标从0开始，因此处理时要全部+1；原题出自2010年四川省选，当时的数据较弱，ODT可以轻松过；但在洛谷上，本题数据经过精心构造，普通ODT只能过3个点。这也是一般ODT只能用作骗分手段的原因。 4. 洛谷P2787 语文1（chin1）- 理理思维又是一道ODT骗分题。前两个操作都是ODT基操，第三个操作开桶排序即可。 查看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include &lt;iostream&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;set&gt;using namespace std;struct node &#123; int l,r; mutable int v; node() &#123;&#125; node(int _l,int _r,int _v): l(_l),r(_r),v(_v) &#123;&#125; const bool operator &lt; (const node&amp; x) const &#123; return l &lt; x.l; &#125;&#125;; typedef set &lt; node &gt; :: iterator iter;set &lt; node &gt; s;string buf;int n,m;int a[100005];inline int read() &#123;#define gc c = getchar() int d = 0,f = 0,gc; while(c &lt; 48 || c &gt; 57) f |= (c == &#x27;-&#x27;),gc; while(c &gt; 47 &amp;&amp; c &lt; 58) d = (d &lt;&lt; 1) + (d &lt;&lt; 3) + (c ^ 48),gc;#undef gc return f ? -d : d;&#125;inline int todigit(char c) &#123; // alpha -&gt; digits if(&#x27;A&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;Z&#x27;) return c - &#x27;A&#x27; + 1; if(&#x27;a&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;z&#x27;) return c - &#x27;a&#x27; + 1;&#125;iter split(int pos) &#123; iter it = s.lower_bound(node(pos,0,0)); if(it != s.end() &amp;&amp; it -&gt; l == pos) return it; it --; int l = it -&gt; l,r = it -&gt; r,v = it -&gt; v; s.erase(it); s.insert(node(l,pos - 1,v)); return s.insert(node(pos,r,v)).first;&#125;void assign(int l,int r,int v) &#123; iter itr = split(r + 1),itl = split(l); s.erase(itl,itr); s.insert(node(l,r,v));&#125;inline int query(int l,int r,int k) &#123; int sum = 0; iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl ++) if(itl -&gt; v == k) sum += itl -&gt; r - itl -&gt; l + 1; return sum;&#125;void bsort(int l,int r) &#123; int pos = l,cnt[27]; memset(cnt,0,sizeof(cnt)); iter itr = split(r + 1),itl = split(l); for(;itl != itr;itl = erase(itl)) cnt[itl -&gt; v] += itl -&gt; r - itl -&gt; l + 1; for(int i = 1;i &lt;= 26;i ++) if(cnt[i]) s.insert(node(pos,pos + cnt[i] - 1,i)),pos += cnt[i];&#125;int main() &#123; n = read(),m = read(); cin &gt;&gt; buf; for(int i = 1;i &lt;= n;i ++) s.insert(node(i,i,todigit(buf[i - 1]))); for(int op,x,y;m;m --) &#123; op = read(),x = read(),y = read(); char k; if(op != 3) &#123; cin &gt;&gt; k; k = todigit(k); &#125; switch(op) &#123; case 1: printf(&quot;%d\\n&quot;,query(x,y,k)); break; case 2: assign(x,y,k); break; case 3: bsort(x,y); break; &#125; &#125; return 0;&#125; 0x04 Epilogue我永远喜欢珂朵莉！（雾 珂朵莉树作为一个较为简单的数据结构，是在OI比赛中骗分的一个不错的工具蒟蒻选手的福音。在许多复杂的线段树题目中，它能够体现出清晰易懂、代码量小的优势。 所以，大家快来膜拜lxl，lxl是我们的光！","categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}],"categories":[{"name":"编程","slug":"编程","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/"},{"name":"字符串","slug":"编程/字符串","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"题解","slug":"编程/题解","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E9%A2%98%E8%A7%A3/"},{"name":"数据结构","slug":"编程/数据结构","permalink":"https://resorie.github.io/blog/categories/%E7%BC%96%E7%A8%8B/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"OI","slug":"OI","permalink":"https://resorie.github.io/blog/tags/OI/"}]}